#' Pcor_SR.test
#'
#' @param object an object of "PartialCor" class, which is generated by "Pcor_SR.def" function.
#'
#' @param boot_SE bootstrap replications. It may be very slow for partial association
#' so a double-check question should be answered before move on.
#' @param H0 null hypothesis of partial correlation coefficient.
#' @param parallel logical argument whether conduct parallel for bootstrapping partial association.
#'
#' @export
Pcor_SR.test <- function(object, boot_SE=100, H0=0, parallel=FALSE) {
  # object <- Pcortest_1; boot_SE=10; H0=0; parallel=TRUE

  n_var <- length(object$models)
  mods_n <- object$mods_n[1]
  arguments <- attr(object, "arguments")
  boot_Cor_temp <- rep(NA, boot_SE) # A vector to save upper triangle matrix. Just work for correlation of a pair.

  # [FEATURE]: standard error from bootstrap: Done!
  if (arguments[1] == "PartialAsso") { # asso_type=="PartialAsso"
    StillBoot <- utils::menu(choices = c("Yes", "No"),
                             title="Using bootstrap to conduct inference of
                                    partial association phi could be slow. \n
                                    Do you really want to continue?")
    if (StillBoot) { # If still run bootstrap, throw messages, otherwise stop.

      if (parallel) { # Use parallel for bootstrapping and "progress" package
        # library(doSNOW); library(parallel)

        numCores <- detectCores()
        cl <- makeCluster(numCores)
        registerDoSNOW(cl)

        pb <- progress_bar$new(
          format = "letter = :letter [:bar] :elapsed | eta: :eta",
          total = boot_SE,    # 100
          width = 60)
        progress_letter <- rep(LETTERS[1:10], 10)  # token reported in progress bar
        # allowing progress bar to be used in foreach -----------------------------
        progress <- function(n){
          pb$tick(tokens = list(letter = progress_letter[n]))
        }

        opts <- list(progress = progress)

        boot_Cor_temp <-
          foreach(j=1:boot_SE,
                  .packages = c('MASS', 'Rfast'),
                  .export=ls(.GlobalEnv), # Try to import package rather than the .GlobalEnv
                  # .export=c("Pcor_SR.def", "resids", "mods_n", "object", "arguments"),
                  .combine=c, .options.snow = opts) %dopar% {
                    tryCatch({
                      index <- sample(mods_n, replace=T)
                      boot_data <- object$data[index, ]
                      Pcortest_1 <-
                        Pcor_SR.def(data = boot_data,
                                    var = attr(object, "var"),
                                    confounder = attr(object, "confounder"),
                                    links=c("probit", "probit"),
                                    asso_type = arguments[1],
                                    cor_method = arguments[2],
                                    surro_method = arguments[3])
                      Pcortest_1$MatCor[1,2]
                    }, error=function(e){})
                  }
        # boot_Cor_temp

        stopCluster(cl)

      } else { # Without using parallel and "progress" package
        # progressBar
        n_prog <- 0
        pb <- txtProgressBar(min = 0, max = boot_SE, style = 3)

        for(i in 1:boot_SE){
          tryCatch({
            index <- sample(mods_n, replace=T)
            boot_data <- object$data[index, ]
            Pcortest_1 <-
              Pcor_SR.def(data = boot_data,
                          var = attr(object, "var"),
                          confounder = attr(object, "confounder"),
                          links=c("probit", "probit"),
                          asso_type = arguments[1],
                          cor_method = arguments[2],
                          surro_method = arguments[3])
            boot_Cor_temp[i]<- Pcortest_1$MatCor[1,2]
          }, error=function(e){})
          # ProgressBar
          n_prog <- n_prog + 1
          setTxtProgressBar(pb, n_prog)
        }
      }

      boot_Cor_temp <- if (n_var==2) { # Generalize the "boot_Cor_temp" when object has more than 2 responses.
        as.matrix(t(boot_Cor_temp))
      } else { as.matrix(boot_Cor_temp) }

      sd_MatCor <- matrix(0, nrow = n_var, ncol = n_var)
      sd_MatCor[upper.tri(sd_MatCor)] <-
        sd_MatCor[lower.tri(sd_MatCor)] <- sqrt(Rfast::rowVars(boot_Cor_temp))
      # Calculate standard error of partial association coefficients!

    } else { #
      stop(call. = FALSE)
    }

  } else { #  asso_type=="Marginal", this can be replaced simply by "cor.test()"
    boot_Cor_temp <-
      sapply(1:boot_SE, # Bootstrapping "boot_SE" times to get standard error!
             function(b, mods_n){
               index <- sample(mods_n[1], replace=T)
               MatCor_temp <- cor(mods_y[index,], method = arguments[2])
               MatCor_temp[upper.tri(sd_MatCor)]
               # cor(mods_y[index,], method = arguments[2])[1,2]
             },
             mods_n=object$mods_n
      )
    boot_Cor_temp <- if (n_var==2) { # Generalize the "boot_Cor_temp" when object has more than 2 responses.
      as.matrix(t(boot_Cor_temp))
    } else { as.matrix(boot_Cor_temp) }

    sd_MatCor <- matrix(0, nrow = n_var, ncol = n_var)
    sd_MatCor[upper.tri(sd_MatCor)] <-
      sd_MatCor[lower.tri(sd_MatCor)] <- sqrt(Rfast::rowVars(boot_Cor_temp))
    # Calculate standard error of partial association coefficients!

  }

  # Return values:
  boot_left <- sum(!is.na(boot_Cor_temp))
  boot_Cor_left <- boot_Cor_temp[!is.na(boot_Cor_temp)]

  if(H0==0){ # Inference of partial correlation coefficients!
    pval <- 2*min(mean(boot_Cor_left>0), mean(boot_Cor_left<0))
  }else{
    pval <- 2*min(mean(boot_Cor_left<H0), mean(boot_Cor_left > -1*H0), 0.5)
  }

  return(list(Cor = mean(boot_Cor_left),
              sd = sd(boot_Cor_left), pval = pval,
              CI = quantile(boot_Cor_left, probs = c(0.025, 0.975)), boot_left=boot_left))


}
