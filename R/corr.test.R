#' corr.test
#'
#' @param object an object of "PartialCor" class, which is generated by "Pcor_SR.def" function.
#'
#' @param boot_SE bootstrap replications. It may be very slow for partial association
#' so a double-check question should be answered before move on.
#' @param H0 null hypothesis of partial correlation coefficient.
#' @param parallel logical argument whether conduct parallel for bootstrapping partial association.
#'
#' @import doSNOW parallel progress
#'
#' @export
corr.test <- function(object, boot_SE=300, H0=0, parallel=FALSE) {
  # object <- PAsso_2; boot_SE=10; H0=0; parallel=TRUE

  responses <- attr(object, "responses")
  adjustments <- attr(object, "adjustments")
  arguments <- attr(object, "arguments")
  MatCor <- object$corr

  n_responses <- length(responses)

  mods_n <- object$mods_n

  boot_Cor_temp <- matrix(NA, ncol = boot_SE, nrow = n_responses*(n_responses-1)/2)
  # A matrix to save all bootstrap correlation coefficients in upper triangle matrix.
  temp_pair <- combn(responses, 2) # result is a matrix, use each column!

  pair_list <- split(x = temp_pair, f = rep(1:ncol(temp_pair), each = nrow(temp_pair)))

  names(pair_list) <- apply(temp_pair, 2, FUN = function(x) paste(x, collapse = "-"))


  # [FEATURE]: standard error from bootstrap: Done!
  if (arguments[1] == "partial") { # association=="partial"
    StillBoot <- utils::menu(choices = c("Yes", "No"),
                             title="Using bootstrap to conduct inference of partial association phi could be slow. \nDo you really want to continue?")
    if (StillBoot) { # If still run bootstrap, throw messages, otherwise stop.

      if (parallel) { # Use parallel for bootstrapping and "progress" package

        # library(doSNOW, parallel, progress)

        numCores <- detectCores()
        cl <- makeCluster(numCores)
        registerDoSNOW(cl)

        pb <- progress_bar$new(
          format = "letter = :letter [:bar] :elapsed | eta: :eta",
          total = boot_SE,    # 100
          width = 60)
        progress_letter <- rep(LETTERS[1:10], 10)  # token reported in progress bar
        # allowing progress bar to be used in foreach -----------------------------
        progress <- function(n){
          pb$tick(tokens = list(letter = progress_letter[n]))
        }

        opts <- list(progress = progress)

        boot_Cor_temp <-
          foreach(j=1:boot_SE,
                  .packages = c('MASS', 'Rfast', 'parasol'),
                  # .export=ls(.GlobalEnv), # Try to import package rather than the .GlobalEnv
                  .export=c("mods_n", "object", "arguments"),
                  .combine=cbind, .options.snow = opts) %dopar% {
                    # tryCatch({
                      index <- sample(mods_n[1], replace=T)
                      boot_data <- as.data.frame(object$data[index, ])
                      Pcor_temp <-
                        corr(data = boot_data,
                             responses = attr(object, "responses"),
                             adjustments = attr(object, "adjustments"),
                             # models=c("probit", "probit"), # in "corr" recover models arguments.
                             association = arguments[1],
                             method = arguments[2],
                             resids.method = arguments[3])
                      Pcor_temp$corr[upper.tri(Pcor_temp$corr)]
                    # }, error=function(e){})
                  }
        # boot_Cor_temp

        stopCluster(cl)

      } else { # Without using parallel and "progress" package
        # progressBar
        n_prog <- 0
        pb <- txtProgressBar(min = 0, max = boot_SE, style = 3)

        for(i in 1:boot_SE){
          tryCatch({
            index <- sample(mods_n[1], replace=T)
            boot_data <- object$data[index, ]
            Pcor_temp <-
              corr(data = boot_data,
                   responses = attr(object, "responses"),
                   adjustments = attr(object, "adjustments"),
                   # models=c("probit", "probit"),
                   association = arguments[1],
                   method = arguments[2],
                   resids.method = arguments[3])
            boot_Cor_temp[,i]<- Pcor_temp$corr[upper.tri(Pcor_temp$corr)]
          }, error=function(e){})
          # ProgressBar
          n_prog <- n_prog + 1
          setTxtProgressBar(pb, n_prog)
        }

      }

      sd_MatCor <- matrix(NA, nrow = n_responses, ncol = n_responses)
      sd_MatCor[upper.tri(sd_MatCor)] <- sqrt(matrixStats::rowVars(boot_Cor_temp))
        # sd_MatCor[lower.tri(sd_MatCor)] <- sd(boot_Cor_temp)
      # Calculate standard error of partial association coefficients!

    } else { #
      stop(call. = FALSE)
    }

    # Return values:
    boot_left <- sum(!is.na(boot_Cor_temp))
    boot_Cor_left <- boot_Cor_temp[, complete.cases(t(boot_Cor_temp))] # Keep complete column

    corr_stat <- corr_p.value <- matrix(NA, nrow = n_responses, ncol = n_responses)

    corr_stat_up <- corr_stat[upper.tri(corr_stat)] <-
      (MatCor[upper.tri(MatCor)] - H0)/sd_MatCor[upper.tri(sd_MatCor)]

    corr_p.value[upper.tri(corr_p.value)] <-
      apply(rbind(pnorm(corr_stat_up),
                  pnorm(corr_stat_up, lower.tail=FALSE)),
            MARGIN = 2,
            FUN = min)

    object$corr_stat <- corr_stat
    object$corr_p.value <- corr_p.value

    CI_temp1 <- rbind(MatCor[upper.tri(MatCor)] - qnorm(0.975) * MatCor[upper.tri(MatCor)] / corr_stat_up,
                      MatCor[upper.tri(MatCor)] + qnorm(0.975) * MatCor[upper.tri(MatCor)] / corr_stat_up)

    CI_temp <- split(x = CI_temp1, f = rep(1:ncol(CI_temp1), each = nrow(CI_temp1)))
    names(CI_temp) <- names(pair_list)

    object$CI_95 <- CI_temp

    # Return a class of "PAsso.test" inheriting from "PAsso".
    class(object) <- c("PAsso.test", class(object))
    object

  } else {
    #  association=="marginal", this can be replaced simply by "cor.test()"

    deal_pair <- function(pair) {
      resp_x <- as.numeric(object$data[,as.character(pair[1])])
      resp_y <- as.numeric(object$data[,as.character(pair[2])])
      cor.test(resp_x,resp_y, method = arguments[2])
      }
    pair_cortest <- lapply(pair_list, FUN = deal_pair) # Correlation tests of all pairs!
    object$pair_cortest <- pair_cortest

    corr_stat <- corr_p.value <- matrix(NA, nrow = n_responses, ncol = n_responses)
    corr_stat[upper.tri(corr_stat)] <- sapply(pair_cortest, FUN = function(x) x$statistic)
    corr_p.value[upper.tri(corr_p.value)] <- sapply(pair_cortest, FUN = function(x) x$p.value)

    object$corr_stat <- corr_stat
    object$corr_p.value <- corr_p.value

    stderror <- sapply(pair_cortest, FUN = function(x) as.vector(x$estimate/x$statistic))
    CI_temp <- lapply(pair_cortest,
                      FUN = function(x) {
                        as.vector(c(x$estimate - qnorm(0.975)*x$estimate/x$statistic,
                                    x$estimate + qnorm(0.975)*x$estimate/x$statistic))
                      })
    object$CI_95 <- CI_temp

    # Return an object of class "MAsso.test" inheriting from "MAsso".
    class(object) <- c("MAsso.test", class(object))
    object

  }


}


#' @return \code{NULL}
#'
#' @rdname print
#' @method print PAsso.test
#'
#' @export
print.PAsso.test <- function(x, digits = max(3, getOption("digits") - 3), ...) {
  # x <- Pcor_SR_test1

  cat("-------------------------------------------- \n")
  cat("The partial association analysis: \n")


  print(signif(x$corr, digits))

}

#' @return \code{NULL}
#'
#' @rdname summary
#' @method summary PAsso.test
#'
#' @export
summary.PAsso.test <- function(x, digits = max(3, getOption("digits") - 3), ...) {
  cat("-------------------------------------------- \n")
  cat("The partial correlation coefficient matrix: \n")
  print(signif(x$corr, digits))

  cat("--------------------------------------------\n")
  cat("\nThe fitted models of the response variables are: \n", sep = "")
  print(x$fitted.models)
}


