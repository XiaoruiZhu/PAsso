#' Hypothesis testing of the partial correlation coefficients by bootstrapping the approach in "corr".
#'
#' This function use bootstrap to conduct hypothesis testing for the partial correlation
#' coefficients. It can directly apply onto the object generated by "corr".
#'
#' @param object An object of "PAsso"/"MAsso" class, which is generated by "corr.def" function.
#'
#' @param boot_SE The number of bootstrap replications. It may be very slow for partial
#' association so a double-check question will ask before move on.
#' @param H0 null hypothesis of partial correlation coefficient.
#' @param parallel logical argument whether conduct parallel for bootstrapping partial association.
#'
#' @import doParallel progress
#' @importFrom utils combn setTxtProgressBar txtProgressBar
#'
#' @export
corr.test <- function(object, boot_SE=300, H0=0, parallel=FALSE) {
  # object <- PAsso_2; boot_SE=10; H0=0; parallel=TRUE

  responses <- attr(object, "responses")
  adjustments <- attr(object, "adjustments")
  arguments <- attr(object, "arguments")

  MatCor <- object$corr

  n_responses <- length(responses)

  mods_n <- object$mods_n

  boot_Cor_temp <- matrix(NA, ncol = boot_SE, nrow = n_responses*(n_responses-1)/2)
  # A matrix to save all bootstrap correlation coefficients in upper triangle matrix.
  temp_pair <- combn(responses, 2) # result is a matrix, use each column!

  pair_list <- split(x = temp_pair, f = rep(1:ncol(temp_pair), each = nrow(temp_pair)))

  names(pair_list) <- apply(temp_pair, 2, FUN = function(x) paste(x, collapse = "-"))


  # Add progress bar --------------------------------------------------------
  pb <- progress_bar$new(
    format = "Replication = :letter [:bar] :percent :elapsed | eta: :eta",
    total = boot_SE,    # 300
    width = 80)
  progress_repNo <- c(1:boot_SE)  # token reported in progress bar


  # [FEATURE]: standard error from bootstrap: Done!
  if (arguments[1] == "partial") { # association=="partial"
    StillBoot <- utils::menu(choices = c("Yes", "No"),
                             title="Using bootstrap to conduct inference of partial association phi could be slow. \nDo you really want to continue?")
    if (StillBoot) { # If still run bootstrap, throw messages, otherwise stop.

      if (parallel) { # Use parallel for bootstrapping and "progress" package

        # numCores <- detectCores() - 1 # Not too aggressive!
        # cl <- makeCluster(numCores)
        # registerDoSNOW(cl)

        # pb <- progress_bar$new(
        #   format = "letter = :letter [:bar] :elapsed | eta: :eta",
        #   total = boot_SE,    # 100
        #   width = 60)
        # progress_letter <- rep(LETTERS[1:10], 10)  # token reported in progress bar

        # allowing progress bar to be used in foreach -----------------------------
        progress <- function(n){
          pb$tick(tokens = list(letter = progress_repNo[n]))
        }

        opts <- list(progress = progress)
        data_temp <- object$data
        boot_Cor_temp <-
          foreach(j=1:boot_SE,
                  .packages = c('MASS', 'matrixStats', 'parasol'),
                  .export=c("mods_n", "data_temp", "arguments"),
                  .combine=cbind, .options.snow = opts) %dopar% {
                    # tryCatch({
                      index <- sample(mods_n[1], replace=T)
                      boot_data <- as.data.frame(data_temp[index, ])
                      Pcor_temp <-
                        corr(data = boot_data,
                             responses = attr(object, "responses"),
                             adjustments = attr(object, "adjustments"),
                             # models=c("probit", "probit"), # in "corr" recover models arguments.
                             association = arguments[1],
                             method = arguments[2],
                             resids.method = arguments[3])
                      Pcor_temp$corr[upper.tri(Pcor_temp$corr)]
                    # }, error=function(e){})
                  }
        # boot_Cor_temp


      } else { # Without using parallel.

        for(i in 1:boot_SE){
          tryCatch({
            index <- sample(mods_n[1], replace=T)
            boot_data <- object$data[index, ]
            Pcor_temp <-
              corr(data = boot_data,
                   responses = attr(object, "responses"),
                   adjustments = attr(object, "adjustments"),
                   # models=c("probit", "probit"),
                   association = arguments[1],
                   method = arguments[2],
                   resids.method = arguments[3])
            boot_Cor_temp[,i]<- Pcor_temp$corr[upper.tri(Pcor_temp$corr)]
          }, error=function(e){})
          # ProgressBar
          pb$tick(tokens = list(letter = progress_repNo[i]))
        }

      }

      # Calculate standard error of partial association coefficients!
      sd_MatCor <- matrix(NA, nrow = n_responses, ncol = n_responses)
      sd_MatCor[upper.tri(sd_MatCor)] <- sqrt(matrixStats::rowVars(boot_Cor_temp))


    } else { #
      stop(call. = TRUE)
    }

    # Return values:
    boot_left <- sum(!is.na(boot_Cor_temp))
    boot_Cor_left <- boot_Cor_temp[, complete.cases(t(boot_Cor_temp))] # Keep complete column

    corr_stat <- corr_p.value <- matrix(NA, nrow = n_responses, ncol = n_responses)

    corr_stat_up <- corr_stat[upper.tri(corr_stat)] <-
      (MatCor[upper.tri(MatCor)] - H0)/sd_MatCor[upper.tri(sd_MatCor)]

    if (H0==0) {
      corr_p.value[upper.tri(corr_p.value)] <-
        2 * apply(rbind(mean(boot_Cor_left>0),
                        mean(boot_Cor_left<0)),
                  MARGIN = 2,
                  FUN = min)
    } else {
      corr_p.value[upper.tri(corr_p.value)] <-
        2 * apply(rbind(mean(boot_Cor_left > -1*H0),
                        mean(boot_Cor_left < H0, 0.5)),
                  MARGIN = 2,
                  FUN = min)
    }

    # Save components: std. Error; statistics; p-value; CI_95.
    object$sd_MatCor <- sd_MatCor
    object$corr_stat <- corr_stat
    object$corr_p.value <- corr_p.value

    # Partial correlation test may be asymmetric, so use quantile.
    CI_temp1 <- apply(X = boot_Cor_left, MARGIN = 1,
                      function(x) quantile(x, probs = c(0.025, 0.975)))
      # rbind(MatCor[upper.tri(MatCor)] - qnorm(0.975) * MatCor[upper.tri(MatCor)] / corr_stat_up,
            # MatCor[upper.tri(MatCor)] + qnorm(0.975) * MatCor[upper.tri(MatCor)] / corr_stat_up)

    CI_temp <- split(x = CI_temp1, f = rep(1:ncol(CI_temp1), each = nrow(CI_temp1)))
    names(CI_temp) <- names(pair_list)

    object$CI_95 <- CI_temp

    # Return a class of "PAsso.test" inheriting from "PAsso".
    attr(object, "boot_SE") <- boot_SE
    attr(object, "H0") <- H0
    class(object) <- c("PAsso.test", class(object))
    object

  } else {
    #  association=="marginal", this can be replaced simply by "cor.test()"

    deal_pair <- function(pair) {
      resp_x <- as.numeric(object$data[,as.character(pair[1])])
      resp_y <- as.numeric(object$data[,as.character(pair[2])])
      cor.test(resp_x,resp_y, method = arguments[2])
      }
    pair_cortest <- lapply(pair_list, FUN = deal_pair) # Correlation tests of all pairs!
    object$pair_cortest <- pair_cortest

    corr_stat <- corr_p.value <- matrix(NA, nrow = n_responses, ncol = n_responses)
    corr_stat[upper.tri(corr_stat)] <- sapply(pair_cortest, FUN = function(x) x$statistic)
    corr_p.value[upper.tri(corr_p.value)] <- sapply(pair_cortest, FUN = function(x) x$p.value)

    sd_MatCor <- sapply(pair_cortest, FUN = function(x) as.vector(x$estimate/x$statistic))

    # Save components: std. Error; statistics; p-value; CI_95.
    object$sd_MatCor <- sd_MatCor
    object$corr_stat <- corr_stat
    object$corr_p.value <- corr_p.value

    # Marginal correlation test is conducted as symmetric.
    CI_temp <- lapply(pair_cortest,
                      FUN = function(x) {
                        as.vector(c(x$estimate - qnorm(0.975)*x$estimate/x$statistic,
                                    x$estimate + qnorm(0.975)*x$estimate/x$statistic))
                      })
    object$CI_95 <- CI_temp

    # Return an object of class "MAsso.test" inheriting from "MAsso".
    attr(object, "boot_SE") <- c(boot_SE)
    attr(object, "H0") <- H0
    class(object) <- c("MAsso.test", class(object))
    object

  }


}

#' @keywords internal
format.pval.corr <-
  function(pv, digits = max(1L, getOption("digits") - 2L),
           eps = .Machine$double.eps,
           na.form = "NA", ..., boot_SE # change .Machine$double.eps to 1/boot
           ) {
    # pv = x$corr_p.value[1,];

    eps <- 1/boot_SE

    if ((has.na <- any(ina <- is.na(pv))))
      pv <- pv[!ina]
    r <- character(length(is0 <- pv < eps))
    if (any(!is0)) {
      rr <- pv <- pv[!is0]
      expo <- floor(log10(ifelse(pv > 0, pv, 1e-50)))
      fixp <- expo >= -3 | (expo == -4 & digits > 1)
      if (any(fixp))
        rr[fixp] <- format(pv[fixp], digits = digits, ...)
      if (any(!fixp))
        rr[!fixp] <- format(pv[!fixp], digits = digits, ...)
      r[!is0] <- rr
    }
    if (any(is0)) {
      digits <- max(1L, digits - 2L)
      if (any(!is0)) {
        nc <- max(nchar(rr, type = "w"))
        if (digits > 1L && digits + 6L > nc)
          digits <- max(1L, nc - 7L)
        sep <- if (digits == 1L && nc <= 6L)
          ""
        else " "
      }
      else sep <- if (digits == 1)
        ""
      else " "
      r[is0] <- paste("<", format(eps, digits = digits, ...),
                      sep = sep)
    }
    if (has.na) {
      rok <- r
      r <- character(length(ina))
      r[!ina] <- rok
      r[ina] <- na.form
    }
    r
  }


#' @rdname print
#' @method print PAsso.test
#'
#' @export
print.PAsso.test <- function(x, digits = max(3L, getOption("digits") - 2L), ...) {
  # x <- PAsso_5v_test
  x$corr[lower.tri(x$corr)] <- NA

  cat("-------------------------------------------- \n")
  cat("The partial association analysis: \n")
  n_rep <- dim(x$corr)[1]
  mat_tem <- matrix(NA, nrow = n_rep*3, ncol = n_rep)

  boot_SE <- attr(x, "boot_SE")

  for (i in 1:(n_rep-1)) {
    mat_tem[(3*i-2),i:n_rep] <-
      format(round(x$corr[i, i:n_rep], digits = digits, ...), nsmall = digits)

    mat_tem[(3*i-1),(i+1):n_rep] <-
      format(round(x$sd_MatCor[i,(i+1):n_rep], digits = digits, ...), nsmall = digits)

    temp_p <- x$corr_p.value[i,(i+1):n_rep]
    Cf_p <- format.pval.corr(temp_p, boot_SE = boot_SE,
                             digits = digits, ...)
    Signif <- symnum(temp_p, corr = FALSE, na = FALSE,
                     cutpoints = c(0, 0.001, 0.01, 0.05, 0.1, 1),
                     symbols = c("***", "**", "*", ".", " "))
    mat_tem[(3*i),(i+1):n_rep] <- paste(Cf_p, format(Signif), sep = "")
    # Std. Error
  }
  mat_tem[(3*n_rep-2),n_rep] <- "1"

  colnames(mat_tem) <- colnames(x$corr)
  temp_rowname <- rep(rownames(x$corr), each=3)
  for (i in 1:(n_rep)) {
    temp_rowname[(3*i-1)] <- "Std. Error"
    temp_rowname[(3*i)] <- "Pr(Signif. codes)"
  }

  rownames(mat_tem) <- temp_rowname

  # mat_tem[is.na(mat_tem)] <- " "
  print(mat_tem, na.print = "")
}

#' @rdname summary
#' @method summary PAsso.test
#'
#' @export
summary.PAsso.test <- function(object, ...) {
  # print(signif(object$corr, ...))
  print(object)

  cat("--------------------------------------------\n")
  cat("\nThe fitted models of the response variables are: \n", sep = "")
  print(object$fitted.models)
}


