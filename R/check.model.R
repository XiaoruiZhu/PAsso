#' A visualization tool of diagnostics of fitted model in the partial association analysis
#'
#' A plot matrix to display the QQ-plot of each fitted model when conducting the partial
#' association analyses. Based on the input of "PAsso" object, each plot stands for the
#' QQ-plot of the surrogate residuals of fitted models. All the plots are based on the
#' surrogate residuals generated from \code{"resides"} function.Graphics are designed
#' based on \code{\link{ggplot2}}.
#'
#' @param object The object in "PAsso" class that is generated by "corr.test" or "corr".
#' @param what A character string specifying what to plot. Default is \code{"qq"} which
#' produces a quantile-quantile plots of the residuals. \code{"fitted"} will give a matrix
#' plot between residuals and fitted response. \code{"covariates"} will give a matrix plot
#' between each residual and each covariate.
#' @param ... Additional optional arguments for drawing plots to be passed onto.
#'
#' @return A list contains plots of \code{"ggplot"} object
#'
#' @rdname checkmodel
#'
#'
#' @export
#'
#' @examples
#' # import data -------------------------------------------------------------
#' data(nes96)
#' summary(nes96)
#' # "corr" function: input three responses ----------------------------
#' PAsso_2 <- corr(responses = c("vote.num", "PID", "selfLR"),
#'                 adjustments = c("income.num", "age", "edu.year"),
#'                 data = nes96,
#'                 models = c("probit", "probit", "probit"),
#'                 association = c("partial"), method = c("kendall"),
#'                 resids.method = "latent", rep_num = 100)
#' print(PAsso_2, digits=5)
#' summary(PAsso_2)
#' check_qq <- checkmodel(object = PAsso_2, color="blue",what = "qq")
#' do.call("grid.arrange", c(check_qq, ncol=1))
#'
#' check_fitted <- checkmodel(object = PAsso_2, what = "fitted")
#' do.call("grid.arrange", c(check_fitted, ncol=1))
#'
#' check_covar <- checkmodel(object = PAsso_2, what = "covariate")
#' do.call("grid.arrange", c(check_covar, ncol=1))
#'
checkmodel <- function(
  object,
  what = c("qq", "fitted", "covariate"),
  ...
) {

  # What type of plot to produce
  what <- match.arg(what, several.ok = FALSE)
  rep_SRs <- object$rep_SRs
  resp_name <- attr(object, "responses")

  n_resp <- length(resp_name)
  nCol <- floor(sqrt(n_resp))
  plot_list <- list()

  # return a matrix-plot including diagnostics of models.
  if (what == "qq") {
    for (i in 1:n_resp) {
      plot_list[[i]] <-
        autoplot.resid(rep_SRs[,1,i], what = what,
                       distribution = qnorm, title = resp_name[i], ...)
    }

    do.call("grid.arrange", c(plot_list, ncol=nCol))

  } else if (what == "fitted") {
    for (i in 1:n_resp) {
      plot_list[[i]] <-
        autoplot(object$fitted.models[[i]], what = what, title = resp_name[i],
                 alpha = 0.5, ...)
    }
    do.call("grid.arrange", c(plot_list, ncol=nCol))

  } else {
    adjust_name <- attr(object, "adjustments")
    n_adjust <- length(adjust_name)
    t_lenght <- n_resp*n_adjust
    adjust_id <- rep(1:n_adjust, times=n_resp) # make index for covariate name in the for loop
    resp_id <- rep(1:n_resp, each=n_adjust) # make index for response name in the for loop

    for (i in 1:(t_lenght)) {
      plot_list[[i]] <-
        autoplot(object$fitted.models[[resp_id[i]]], what = "covariate",
                 x = object$data[,adjust_name[adjust_id[i]]],
                 xlab = adjust_name[adjust_id[i]],
                 title = resp_name[resp_id[i]], ...)

    }
    do.call("grid.arrange", c(plot_list, ncol=n_adjust))
  }

  return(plot_list)
}

